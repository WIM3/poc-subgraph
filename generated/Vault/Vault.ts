// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class BadDebtSettled extends ethereum.Event {
  get params(): BadDebtSettled__Params {
    return new BadDebtSettled__Params(this);
  }
}

export class BadDebtSettled__Params {
  _event: BadDebtSettled;

  constructor(event: BadDebtSettled) {
    this._event = event;
  }

  get trader(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class ClearingHouseChanged extends ethereum.Event {
  get params(): ClearingHouseChanged__Params {
    return new ClearingHouseChanged__Params(this);
  }
}

export class ClearingHouseChanged__Params {
  _event: ClearingHouseChanged;

  constructor(event: ClearingHouseChanged) {
    this._event = event;
  }

  get clearingHouse(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class CollateralLiquidated extends ethereum.Event {
  get params(): CollateralLiquidated__Params {
    return new CollateralLiquidated__Params(this);
  }
}

export class CollateralLiquidated__Params {
  _event: CollateralLiquidated;

  constructor(event: CollateralLiquidated) {
    this._event = event;
  }

  get trader(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get collateralToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get liquidator(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get collateral(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get repaidSettlementWithoutInsuranceFundFeeX10_S(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get insuranceFundFeeX10_S(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get discountRatio(): i32 {
    return this._event.parameters[6].value.toI32();
  }
}

export class CollateralManagerChanged extends ethereum.Event {
  get params(): CollateralManagerChanged__Params {
    return new CollateralManagerChanged__Params(this);
  }
}

export class CollateralManagerChanged__Params {
  _event: CollateralManagerChanged;

  constructor(event: CollateralManagerChanged) {
    this._event = event;
  }

  get collateralManager(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Deposited extends ethereum.Event {
  get params(): Deposited__Params {
    return new Deposited__Params(this);
  }
}

export class Deposited__Params {
  _event: Deposited;

  constructor(event: Deposited) {
    this._event = event;
  }

  get collateralToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get trader(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class Paused extends ethereum.Event {
  get params(): Paused__Params {
    return new Paused__Params(this);
  }
}

export class Paused__Params {
  _event: Paused;

  constructor(event: Paused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class TrustedForwarderChanged extends ethereum.Event {
  get params(): TrustedForwarderChanged__Params {
    return new TrustedForwarderChanged__Params(this);
  }
}

export class TrustedForwarderChanged__Params {
  _event: TrustedForwarderChanged;

  constructor(event: TrustedForwarderChanged) {
    this._event = event;
  }

  get trustedForwarder(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class TrustedForwarderUpdated extends ethereum.Event {
  get params(): TrustedForwarderUpdated__Params {
    return new TrustedForwarderUpdated__Params(this);
  }
}

export class TrustedForwarderUpdated__Params {
  _event: TrustedForwarderUpdated;

  constructor(event: TrustedForwarderUpdated) {
    this._event = event;
  }

  get trustedForwarder(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Unpaused extends ethereum.Event {
  get params(): Unpaused__Params {
    return new Unpaused__Params(this);
  }
}

export class Unpaused__Params {
  _event: Unpaused;

  constructor(event: Unpaused) {
    this._event = event;
  }

  get account(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class WETH9Changed extends ethereum.Event {
  get params(): WETH9Changed__Params {
    return new WETH9Changed__Params(this);
  }
}

export class WETH9Changed__Params {
  _event: WETH9Changed;

  constructor(event: WETH9Changed) {
    this._event = event;
  }

  get WETH9(): Address {
    return this._event.parameters[0].value.toAddress();
  }
}

export class Withdrawn extends ethereum.Event {
  get params(): Withdrawn__Params {
    return new Withdrawn__Params(this);
  }
}

export class Withdrawn__Params {
  _event: Withdrawn;

  constructor(event: Withdrawn) {
    this._event = event;
  }

  get collateralToken(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get trader(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Vault__getMaxRepaidSettlementAndLiquidatableCollateralResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    return map;
  }

  getMaxRepaidSettlementX10_S(): BigInt {
    return this.value0;
  }

  getMaxLiquidatableCollateral(): BigInt {
    return this.value1;
  }
}

export class Vault extends ethereum.SmartContract {
  static bind(address: Address): Vault {
    return new Vault("Vault", address);
  }

  candidate(): Address {
    let result = super.call("candidate", "candidate():(address)", []);

    return result[0].toAddress();
  }

  try_candidate(): ethereum.CallResult<Address> {
    let result = super.tryCall("candidate", "candidate():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  decimals(): i32 {
    let result = super.call("decimals", "decimals():(uint8)", []);

    return result[0].toI32();
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getAccountBalance(): Address {
    let result = super.call(
      "getAccountBalance",
      "getAccountBalance():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getAccountBalance(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getAccountBalance",
      "getAccountBalance():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getAccountValue(trader: Address): BigInt {
    let result = super.call(
      "getAccountValue",
      "getAccountValue(address):(int256)",
      [ethereum.Value.fromAddress(trader)]
    );

    return result[0].toBigInt();
  }

  try_getAccountValue(trader: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAccountValue",
      "getAccountValue(address):(int256)",
      [ethereum.Value.fromAddress(trader)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBalance(trader: Address): BigInt {
    let result = super.call("getBalance", "getBalance(address):(int256)", [
      ethereum.Value.fromAddress(trader)
    ]);

    return result[0].toBigInt();
  }

  try_getBalance(trader: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getBalance", "getBalance(address):(int256)", [
      ethereum.Value.fromAddress(trader)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getBalanceByToken(trader: Address, token: Address): BigInt {
    let result = super.call(
      "getBalanceByToken",
      "getBalanceByToken(address,address):(int256)",
      [ethereum.Value.fromAddress(trader), ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_getBalanceByToken(
    trader: Address,
    token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getBalanceByToken",
      "getBalanceByToken(address,address):(int256)",
      [ethereum.Value.fromAddress(trader), ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getClearingHouse(): Address {
    let result = super.call(
      "getClearingHouse",
      "getClearingHouse():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getClearingHouse(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getClearingHouse",
      "getClearingHouse():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getClearingHouseConfig(): Address {
    let result = super.call(
      "getClearingHouseConfig",
      "getClearingHouseConfig():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getClearingHouseConfig(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getClearingHouseConfig",
      "getClearingHouseConfig():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getCollateralManager(): Address {
    let result = super.call(
      "getCollateralManager",
      "getCollateralManager():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getCollateralManager(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getCollateralManager",
      "getCollateralManager():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getCollateralMmRatio(): i32 {
    let result = super.call(
      "getCollateralMmRatio",
      "getCollateralMmRatio():(uint24)",
      []
    );

    return result[0].toI32();
  }

  try_getCollateralMmRatio(): ethereum.CallResult<i32> {
    let result = super.tryCall(
      "getCollateralMmRatio",
      "getCollateralMmRatio():(uint24)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  getCollateralTokens(trader: Address): Array<Address> {
    let result = super.call(
      "getCollateralTokens",
      "getCollateralTokens(address):(address[])",
      [ethereum.Value.fromAddress(trader)]
    );

    return result[0].toAddressArray();
  }

  try_getCollateralTokens(
    trader: Address
  ): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "getCollateralTokens",
      "getCollateralTokens(address):(address[])",
      [ethereum.Value.fromAddress(trader)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  getExchange(): Address {
    let result = super.call("getExchange", "getExchange():(address)", []);

    return result[0].toAddress();
  }

  try_getExchange(): ethereum.CallResult<Address> {
    let result = super.tryCall("getExchange", "getExchange():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getFreeCollateral(trader: Address): BigInt {
    let result = super.call(
      "getFreeCollateral",
      "getFreeCollateral(address):(uint256)",
      [ethereum.Value.fromAddress(trader)]
    );

    return result[0].toBigInt();
  }

  try_getFreeCollateral(trader: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getFreeCollateral",
      "getFreeCollateral(address):(uint256)",
      [ethereum.Value.fromAddress(trader)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getFreeCollateralByRatio(trader: Address, ratio: i32): BigInt {
    let result = super.call(
      "getFreeCollateralByRatio",
      "getFreeCollateralByRatio(address,uint24):(int256)",
      [
        ethereum.Value.fromAddress(trader),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(ratio))
      ]
    );

    return result[0].toBigInt();
  }

  try_getFreeCollateralByRatio(
    trader: Address,
    ratio: i32
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getFreeCollateralByRatio",
      "getFreeCollateralByRatio(address,uint24):(int256)",
      [
        ethereum.Value.fromAddress(trader),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(ratio))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getFreeCollateralByToken(trader: Address, token: Address): BigInt {
    let result = super.call(
      "getFreeCollateralByToken",
      "getFreeCollateralByToken(address,address):(uint256)",
      [ethereum.Value.fromAddress(trader), ethereum.Value.fromAddress(token)]
    );

    return result[0].toBigInt();
  }

  try_getFreeCollateralByToken(
    trader: Address,
    token: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getFreeCollateralByToken",
      "getFreeCollateralByToken(address,address):(uint256)",
      [ethereum.Value.fromAddress(trader), ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getInsuranceFund(): Address {
    let result = super.call(
      "getInsuranceFund",
      "getInsuranceFund():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getInsuranceFund(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getInsuranceFund",
      "getInsuranceFund():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getLiquidatableCollateralBySettlement(
    token: Address,
    settlementX10_S: BigInt
  ): BigInt {
    let result = super.call(
      "getLiquidatableCollateralBySettlement",
      "getLiquidatableCollateralBySettlement(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(settlementX10_S)
      ]
    );

    return result[0].toBigInt();
  }

  try_getLiquidatableCollateralBySettlement(
    token: Address,
    settlementX10_S: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getLiquidatableCollateralBySettlement",
      "getLiquidatableCollateralBySettlement(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(settlementX10_S)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMarginRequirementForCollateralLiquidation(trader: Address): BigInt {
    let result = super.call(
      "getMarginRequirementForCollateralLiquidation",
      "getMarginRequirementForCollateralLiquidation(address):(int256)",
      [ethereum.Value.fromAddress(trader)]
    );

    return result[0].toBigInt();
  }

  try_getMarginRequirementForCollateralLiquidation(
    trader: Address
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getMarginRequirementForCollateralLiquidation",
      "getMarginRequirementForCollateralLiquidation(address):(int256)",
      [ethereum.Value.fromAddress(trader)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getMaxRepaidSettlementAndLiquidatableCollateral(
    trader: Address,
    token: Address
  ): Vault__getMaxRepaidSettlementAndLiquidatableCollateralResult {
    let result = super.call(
      "getMaxRepaidSettlementAndLiquidatableCollateral",
      "getMaxRepaidSettlementAndLiquidatableCollateral(address,address):(uint256,uint256)",
      [ethereum.Value.fromAddress(trader), ethereum.Value.fromAddress(token)]
    );

    return new Vault__getMaxRepaidSettlementAndLiquidatableCollateralResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_getMaxRepaidSettlementAndLiquidatableCollateral(
    trader: Address,
    token: Address
  ): ethereum.CallResult<
    Vault__getMaxRepaidSettlementAndLiquidatableCollateralResult
  > {
    let result = super.tryCall(
      "getMaxRepaidSettlementAndLiquidatableCollateral",
      "getMaxRepaidSettlementAndLiquidatableCollateral(address,address):(uint256,uint256)",
      [ethereum.Value.fromAddress(trader), ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new Vault__getMaxRepaidSettlementAndLiquidatableCollateralResult(
        value[0].toBigInt(),
        value[1].toBigInt()
      )
    );
  }

  getRepaidSettlementByCollateral(token: Address, collateral: BigInt): BigInt {
    let result = super.call(
      "getRepaidSettlementByCollateral",
      "getRepaidSettlementByCollateral(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(collateral)
      ]
    );

    return result[0].toBigInt();
  }

  try_getRepaidSettlementByCollateral(
    token: Address,
    collateral: BigInt
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getRepaidSettlementByCollateral",
      "getRepaidSettlementByCollateral(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(collateral)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSettlementToken(): Address {
    let result = super.call(
      "getSettlementToken",
      "getSettlementToken():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getSettlementToken(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getSettlementToken",
      "getSettlementToken():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getSettlementTokenValue(trader: Address): BigInt {
    let result = super.call(
      "getSettlementTokenValue",
      "getSettlementTokenValue(address):(int256)",
      [ethereum.Value.fromAddress(trader)]
    );

    return result[0].toBigInt();
  }

  try_getSettlementTokenValue(trader: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getSettlementTokenValue",
      "getSettlementTokenValue(address):(int256)",
      [ethereum.Value.fromAddress(trader)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTotalDebt(): BigInt {
    let result = super.call("getTotalDebt", "getTotalDebt():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getTotalDebt(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getTotalDebt", "getTotalDebt():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTrustedForwarder(): Address {
    let result = super.call(
      "getTrustedForwarder",
      "getTrustedForwarder():(address)",
      []
    );

    return result[0].toAddress();
  }

  try_getTrustedForwarder(): ethereum.CallResult<Address> {
    let result = super.tryCall(
      "getTrustedForwarder",
      "getTrustedForwarder():(address)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getWETH9(): Address {
    let result = super.call("getWETH9", "getWETH9():(address)", []);

    return result[0].toAddress();
  }

  try_getWETH9(): ethereum.CallResult<Address> {
    let result = super.tryCall("getWETH9", "getWETH9():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  isLiquidatable(trader: Address): boolean {
    let result = super.call(
      "isLiquidatable",
      "isLiquidatable(address):(bool)",
      [ethereum.Value.fromAddress(trader)]
    );

    return result[0].toBoolean();
  }

  try_isLiquidatable(trader: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isLiquidatable",
      "isLiquidatable(address):(bool)",
      [ethereum.Value.fromAddress(trader)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isTrustedForwarder(forwarder: Address): boolean {
    let result = super.call(
      "isTrustedForwarder",
      "isTrustedForwarder(address):(bool)",
      [ethereum.Value.fromAddress(forwarder)]
    );

    return result[0].toBoolean();
  }

  try_isTrustedForwarder(forwarder: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isTrustedForwarder",
      "isTrustedForwarder(address):(bool)",
      [ethereum.Value.fromAddress(forwarder)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  liquidateCollateral(
    trader: Address,
    token: Address,
    amount: BigInt,
    isDenominatedInSettlementToken: boolean
  ): BigInt {
    let result = super.call(
      "liquidateCollateral",
      "liquidateCollateral(address,address,uint256,bool):(uint256)",
      [
        ethereum.Value.fromAddress(trader),
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isDenominatedInSettlementToken)
      ]
    );

    return result[0].toBigInt();
  }

  try_liquidateCollateral(
    trader: Address,
    token: Address,
    amount: BigInt,
    isDenominatedInSettlementToken: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "liquidateCollateral",
      "liquidateCollateral(address,address,uint256,bool):(uint256)",
      [
        ethereum.Value.fromAddress(trader),
        ethereum.Value.fromAddress(token),
        ethereum.Value.fromUnsignedBigInt(amount),
        ethereum.Value.fromBoolean(isDenominatedInSettlementToken)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  paused(): boolean {
    let result = super.call("paused", "paused():(bool)", []);

    return result[0].toBoolean();
  }

  try_paused(): ethereum.CallResult<boolean> {
    let result = super.tryCall("paused", "paused():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  versionRecipient(): string {
    let result = super.call(
      "versionRecipient",
      "versionRecipient():(string)",
      []
    );

    return result[0].toString();
  }

  try_versionRecipient(): ethereum.CallResult<string> {
    let result = super.tryCall(
      "versionRecipient",
      "versionRecipient():(string)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  withdrawAll(token: Address): BigInt {
    let result = super.call("withdrawAll", "withdrawAll(address):(uint256)", [
      ethereum.Value.fromAddress(token)
    ]);

    return result[0].toBigInt();
  }

  try_withdrawAll(token: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawAll",
      "withdrawAll(address):(uint256)",
      [ethereum.Value.fromAddress(token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  withdrawAllEther(): BigInt {
    let result = super.call(
      "withdrawAllEther",
      "withdrawAllEther():(uint256)",
      []
    );

    return result[0].toBigInt();
  }

  try_withdrawAllEther(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "withdrawAllEther",
      "withdrawAllEther():(uint256)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class DepositCall extends ethereum.Call {
  get inputs(): DepositCall__Inputs {
    return new DepositCall__Inputs(this);
  }

  get outputs(): DepositCall__Outputs {
    return new DepositCall__Outputs(this);
  }
}

export class DepositCall__Inputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class DepositCall__Outputs {
  _call: DepositCall;

  constructor(call: DepositCall) {
    this._call = call;
  }
}

export class DepositEtherCall extends ethereum.Call {
  get inputs(): DepositEtherCall__Inputs {
    return new DepositEtherCall__Inputs(this);
  }

  get outputs(): DepositEtherCall__Outputs {
    return new DepositEtherCall__Outputs(this);
  }
}

export class DepositEtherCall__Inputs {
  _call: DepositEtherCall;

  constructor(call: DepositEtherCall) {
    this._call = call;
  }
}

export class DepositEtherCall__Outputs {
  _call: DepositEtherCall;

  constructor(call: DepositEtherCall) {
    this._call = call;
  }
}

export class DepositEtherForCall extends ethereum.Call {
  get inputs(): DepositEtherForCall__Inputs {
    return new DepositEtherForCall__Inputs(this);
  }

  get outputs(): DepositEtherForCall__Outputs {
    return new DepositEtherForCall__Outputs(this);
  }
}

export class DepositEtherForCall__Inputs {
  _call: DepositEtherForCall;

  constructor(call: DepositEtherForCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class DepositEtherForCall__Outputs {
  _call: DepositEtherForCall;

  constructor(call: DepositEtherForCall) {
    this._call = call;
  }
}

export class DepositForCall extends ethereum.Call {
  get inputs(): DepositForCall__Inputs {
    return new DepositForCall__Inputs(this);
  }

  get outputs(): DepositForCall__Outputs {
    return new DepositForCall__Outputs(this);
  }
}

export class DepositForCall__Inputs {
  _call: DepositForCall;

  constructor(call: DepositForCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class DepositForCall__Outputs {
  _call: DepositForCall;

  constructor(call: DepositForCall) {
    this._call = call;
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get insuranceFundArg(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get clearingHouseConfigArg(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get accountBalanceArg(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get exchangeArg(): Address {
    return this._call.inputValues[3].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class LiquidateCollateralCall extends ethereum.Call {
  get inputs(): LiquidateCollateralCall__Inputs {
    return new LiquidateCollateralCall__Inputs(this);
  }

  get outputs(): LiquidateCollateralCall__Outputs {
    return new LiquidateCollateralCall__Outputs(this);
  }
}

export class LiquidateCollateralCall__Inputs {
  _call: LiquidateCollateralCall;

  constructor(call: LiquidateCollateralCall) {
    this._call = call;
  }

  get trader(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get token(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get isDenominatedInSettlementToken(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class LiquidateCollateralCall__Outputs {
  _call: LiquidateCollateralCall;

  constructor(call: LiquidateCollateralCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class PauseCall extends ethereum.Call {
  get inputs(): PauseCall__Inputs {
    return new PauseCall__Inputs(this);
  }

  get outputs(): PauseCall__Outputs {
    return new PauseCall__Outputs(this);
  }
}

export class PauseCall__Inputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class PauseCall__Outputs {
  _call: PauseCall;

  constructor(call: PauseCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SetClearingHouseCall extends ethereum.Call {
  get inputs(): SetClearingHouseCall__Inputs {
    return new SetClearingHouseCall__Inputs(this);
  }

  get outputs(): SetClearingHouseCall__Outputs {
    return new SetClearingHouseCall__Outputs(this);
  }
}

export class SetClearingHouseCall__Inputs {
  _call: SetClearingHouseCall;

  constructor(call: SetClearingHouseCall) {
    this._call = call;
  }

  get clearingHouseArg(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetClearingHouseCall__Outputs {
  _call: SetClearingHouseCall;

  constructor(call: SetClearingHouseCall) {
    this._call = call;
  }
}

export class SetCollateralManagerCall extends ethereum.Call {
  get inputs(): SetCollateralManagerCall__Inputs {
    return new SetCollateralManagerCall__Inputs(this);
  }

  get outputs(): SetCollateralManagerCall__Outputs {
    return new SetCollateralManagerCall__Outputs(this);
  }
}

export class SetCollateralManagerCall__Inputs {
  _call: SetCollateralManagerCall;

  constructor(call: SetCollateralManagerCall) {
    this._call = call;
  }

  get collateralManagerArg(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetCollateralManagerCall__Outputs {
  _call: SetCollateralManagerCall;

  constructor(call: SetCollateralManagerCall) {
    this._call = call;
  }
}

export class SetOwnerCall extends ethereum.Call {
  get inputs(): SetOwnerCall__Inputs {
    return new SetOwnerCall__Inputs(this);
  }

  get outputs(): SetOwnerCall__Outputs {
    return new SetOwnerCall__Outputs(this);
  }
}

export class SetOwnerCall__Inputs {
  _call: SetOwnerCall;

  constructor(call: SetOwnerCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetOwnerCall__Outputs {
  _call: SetOwnerCall;

  constructor(call: SetOwnerCall) {
    this._call = call;
  }
}

export class SetTrustedForwarderCall extends ethereum.Call {
  get inputs(): SetTrustedForwarderCall__Inputs {
    return new SetTrustedForwarderCall__Inputs(this);
  }

  get outputs(): SetTrustedForwarderCall__Outputs {
    return new SetTrustedForwarderCall__Outputs(this);
  }
}

export class SetTrustedForwarderCall__Inputs {
  _call: SetTrustedForwarderCall;

  constructor(call: SetTrustedForwarderCall) {
    this._call = call;
  }

  get trustedForwarderArg(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetTrustedForwarderCall__Outputs {
  _call: SetTrustedForwarderCall;

  constructor(call: SetTrustedForwarderCall) {
    this._call = call;
  }
}

export class SetWETH9Call extends ethereum.Call {
  get inputs(): SetWETH9Call__Inputs {
    return new SetWETH9Call__Inputs(this);
  }

  get outputs(): SetWETH9Call__Outputs {
    return new SetWETH9Call__Outputs(this);
  }
}

export class SetWETH9Call__Inputs {
  _call: SetWETH9Call;

  constructor(call: SetWETH9Call) {
    this._call = call;
  }

  get WETH9Arg(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetWETH9Call__Outputs {
  _call: SetWETH9Call;

  constructor(call: SetWETH9Call) {
    this._call = call;
  }
}

export class SettleBadDebtCall extends ethereum.Call {
  get inputs(): SettleBadDebtCall__Inputs {
    return new SettleBadDebtCall__Inputs(this);
  }

  get outputs(): SettleBadDebtCall__Outputs {
    return new SettleBadDebtCall__Outputs(this);
  }
}

export class SettleBadDebtCall__Inputs {
  _call: SettleBadDebtCall;

  constructor(call: SettleBadDebtCall) {
    this._call = call;
  }

  get trader(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SettleBadDebtCall__Outputs {
  _call: SettleBadDebtCall;

  constructor(call: SettleBadDebtCall) {
    this._call = call;
  }
}

export class UnpauseCall extends ethereum.Call {
  get inputs(): UnpauseCall__Inputs {
    return new UnpauseCall__Inputs(this);
  }

  get outputs(): UnpauseCall__Outputs {
    return new UnpauseCall__Outputs(this);
  }
}

export class UnpauseCall__Inputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UnpauseCall__Outputs {
  _call: UnpauseCall;

  constructor(call: UnpauseCall) {
    this._call = call;
  }
}

export class UpdateOwnerCall extends ethereum.Call {
  get inputs(): UpdateOwnerCall__Inputs {
    return new UpdateOwnerCall__Inputs(this);
  }

  get outputs(): UpdateOwnerCall__Outputs {
    return new UpdateOwnerCall__Outputs(this);
  }
}

export class UpdateOwnerCall__Inputs {
  _call: UpdateOwnerCall;

  constructor(call: UpdateOwnerCall) {
    this._call = call;
  }
}

export class UpdateOwnerCall__Outputs {
  _call: UpdateOwnerCall;

  constructor(call: UpdateOwnerCall) {
    this._call = call;
  }
}

export class WithdrawCall extends ethereum.Call {
  get inputs(): WithdrawCall__Inputs {
    return new WithdrawCall__Inputs(this);
  }

  get outputs(): WithdrawCall__Outputs {
    return new WithdrawCall__Outputs(this);
  }
}

export class WithdrawCall__Inputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WithdrawCall__Outputs {
  _call: WithdrawCall;

  constructor(call: WithdrawCall) {
    this._call = call;
  }
}

export class WithdrawAllCall extends ethereum.Call {
  get inputs(): WithdrawAllCall__Inputs {
    return new WithdrawAllCall__Inputs(this);
  }

  get outputs(): WithdrawAllCall__Outputs {
    return new WithdrawAllCall__Outputs(this);
  }
}

export class WithdrawAllCall__Inputs {
  _call: WithdrawAllCall;

  constructor(call: WithdrawAllCall) {
    this._call = call;
  }

  get token(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class WithdrawAllCall__Outputs {
  _call: WithdrawAllCall;

  constructor(call: WithdrawAllCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class WithdrawAllEtherCall extends ethereum.Call {
  get inputs(): WithdrawAllEtherCall__Inputs {
    return new WithdrawAllEtherCall__Inputs(this);
  }

  get outputs(): WithdrawAllEtherCall__Outputs {
    return new WithdrawAllEtherCall__Outputs(this);
  }
}

export class WithdrawAllEtherCall__Inputs {
  _call: WithdrawAllEtherCall;

  constructor(call: WithdrawAllEtherCall) {
    this._call = call;
  }
}

export class WithdrawAllEtherCall__Outputs {
  _call: WithdrawAllEtherCall;

  constructor(call: WithdrawAllEtherCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class WithdrawEtherCall extends ethereum.Call {
  get inputs(): WithdrawEtherCall__Inputs {
    return new WithdrawEtherCall__Inputs(this);
  }

  get outputs(): WithdrawEtherCall__Outputs {
    return new WithdrawEtherCall__Outputs(this);
  }
}

export class WithdrawEtherCall__Inputs {
  _call: WithdrawEtherCall;

  constructor(call: WithdrawEtherCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class WithdrawEtherCall__Outputs {
  _call: WithdrawEtherCall;

  constructor(call: WithdrawEtherCall) {
    this._call = call;
  }
}
